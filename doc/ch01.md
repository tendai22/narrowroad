---
link:
  - rel: 'stylesheet'
    href: 'css/sample1.css'
lang: ja
---
# 1. FORTHが生まれた世界

1970年代のミニコン上のプログラミング環境を感じられるプロセスを、今風の自作ワンボードマイコンと母艦PCの組み合わせの上に実現し、68000機械語・アセンブリ言語で FORTHのワードを整えてゆきます。

私にとってFORTHの魅力は、言語としての側面よりも、実行環境としての側面にある。

* サブルーチンのアドレスを2重ポインタでたどって呼び出してゆく、シンプルな「インタプリタ」。
* 機械語サブルーチンではあるが、部品化して組み合わせるための仕組みである「単語」「辞書」「コンパイル」
* これらの単純な仕組みの組み合わせで「アプリケーション志向」でアプリケーションにくみ上げてゆくプログラミングスタイル。

UNIXでプログラミングに目覚め「小さな部品を組み合わせて問題を解いてゆく」スタイルがしみついている、今でもシェルスクリプトでバッククォート、sedを日常的に使う私にとって、もうひとつの「部品を組み合わせて問題を解いてゆく」仕組みとして魅力的である。UNIXがない時代の「部品箱」アプローチはとても興味深い。

FORTHを発明したCharles Mooreは、機械語サブルーチンの束とインタプリタを引っ提げて、顧客の求めるミニコンに開発環境を一から移植し、その上にアプリケーションを組んだ。この作業を数10種類のミニコンに対して繰り返す中で、FORTH言語が形作られていった。

ならば、私も彼のたどった道をたどろう。新しいCPUに対して、アセンブリ言語を使って機械語サブルーチンを一つ一つ作ってゆく。最終的にFORTH言語が動くようにする。彼が数10回たどった道だが、私がさらに1回たどってもいいじゃないか。このシンプルな開発環境・実行環境を体で味わいたい。ということだ。

* サブルーチン先頭のアドレスの列をソフトウェア部品として実行する。実行は2重ポインタの参照なので実行コードへのジャンプは高速である。
* プログラムはテキストで表現されているが、アドレスの列に変換した状態でメモリ上に展開しているので高速実行できる。
* テキストを解釈する際は空白で区切られた「単語」単位に区切り、単語に対応する部品のアドレスを見つけ出し実行する。

幾つかの機械語部品以外は、すべて数10個のアドレスの列(ポインタの配列)なのでコンパクトであり、当時の限られたメモリ容量でもある程度の規模のアプリケーションを組むことが出来た。

数キロバイトのメモリ、ハードディスクと低速の端末、機械語によるプログラミングで腕を磨いたMooreは、自分独自の開発環境を作り上げてゆく、さまざまなマシンの仕事を受け手元のソフトウェア部品をインタプリタで組み合わせて仕事をこなしてゆく中で彼が作り出したものがFORTHという開発環境だった。60年後半から70年代前半にはコンパイラやライブラリは提供されているがコード品質はよくわからない状況で、自分の手元にある機械語サブルーチンの束を組み合わせて顧客要望に応える。新たなCPUの仕事を受けるとアセンブラを作るところから始め、用意した機械語ルーチン群を「移植」してゆく。数10種類のコンピュータに対してそれを繰り返す中でFORTHという仕組みが出来上がっていった。

* アドレス解決済のサブルーチン呼び出しの列を順次呼び出してゆく実行方法(内部インタプリタ)
* 入力プログラムを単語に区切って、単語を名前-コードのペアのエントリの片方向リスト(辞書)で検索して見つかったコードのアドレスを実行する(外部インタプリタ)
* 単語の列で構成されたモジュールを、辞書で検索してコードのアドレスをメモリ上に順次並べ、そのリストを新しい辞書エントリとする(コンパイル)

という処理をベースとして、

FORTHとして最も初期の記述は[(Moore74)"FORTH: A NEW WAY TO PROGRAM A MINI-COMPUTER"](https://adsabs.harvard.edu/full/1974A%26AS...15..497M)にある。RAM 8kバイト、ハードディスクと端末のつながったミニコンピュータ、フロントパネルのスイッチを操作して、数10バイトのブートローダを1バイト1バイト手打ちで入力して、紙テープからコンパイラを読み込ませ実行する環境。おそらく、FORTH実行環境は紙テープに打ち込んでおき、手打ちブートローダから読み込んでRUNしていたのでしょう。

FORTH実行環境は2kバイトだとのこと。現在の我々の住まいの1000分の1、ひょっとすると100万分の一かもしれない。アプリケーションも数キロバイト、データ領域も数キロバイトの規模感である。現在を生きる我々がこの規模感の世界で何か役に立つ・実用的なものを開発すること自体に意味がないことは、私自身も承知している。だが、Mooreはこの環境で天文台向けアプリケーション(おそらく、望遠鏡を天空の一点に向けながら写真を撮像するようなものなのだろう)を開発し、当時の天文台の人気を博したというのだ。小さな部品の組み合わせ、言語ではあるが、既にある部品とアプリケーション用の部品を追加で開発し組み合わせる。2kBのメモリでも動作する「インタプリタ」と「コンパイラ」なら、我々の世代ならVTLやTiny BASICを思い浮かべるだろう。だが、FORTHには「ソース読み込み・解釈部」自体も幾つかの部品の組み合わせでできており、ここをカスタマイズすることもできる。例えば、単語の文字並びの定義も変えることができる。あるアプリケーションの機能を単語として定義してそろえてゆくだけでなく、実際にアプリケーションを実行する際の「入力」の構文も専用化することができる。この辺りは他の言語・実行環境ではなかなかできるものではない。

Mooreは「ジョン・マッカーシからLispを学んだ」ことがあると言う。1960年に学士取得後にスタンフォードで2年間数学を学んだ時のことらしい。Lispのインタラクティブ性、(S式の範囲ではあるが)パーザも自作できる環境についても知っていたと推測する。

> IBM704で Fortran IIを使用(1958年)。このプログラムをアセンブラに圧縮し、衛星軌道を決定(1959年)。一方、スタンフォード線形加速器センターで電子ビームのステアリングを最適化するためにバロウズB5500用のAlgolを習得(1962年)。Charles H Moore and Associatesとして、タイムシェアリングサービスをサポートするためにFortran-Algolトランスレータを作成しました(1964年)。また、最初のミニコンピュータでリアルタイムのガスクロマトグラフをプログラミングした(1965年)。モハスコ社でオーダーエントリネットワークをプログラムするために Cobol を習得した(1968)。[PROGRAMMING A PROBLEM ORIENTED LANGUAGE, Moore70b]

FORTHを発明するまでにこれだけの経験を積んでいた。Fortran/Algol言語に熟知し、最終的にアセンブリ言語で書くことを躊躇しない(というか、アセンブリ言語で書かざるをえなかった)し、実際にアセンブリ言語で書いて仕事ができたのだろう。

## FORTHの誕生

[Evolution-FORTH]にはMooreがFORTHを誕生させた経緯について説明がある。

1960年に、スミソニアン天文台で天文関係の計算を行うプログラムを開発していた。
彼自身が開発・蓄積したプログラムの「構成管理」のためのインタプリタを自分で開発したというのが、のちのForthにつながっているらしい。

> 「カードトレイ2枚を埋め尽くす」規模に成長した彼のプログラムの再コンパイルの手間と時間を最小にするために、プログラムを制御するカードを読み取る簡単なインタプリタを開発した。これにより、彼は再コンパイルすることなく、複数の衛星のために異なる方程式を構成することができた。

> このインタプリタには、現代のForthに受け継がれているいくつかのコマンドとコンセプトがあり、主にスペースで区切られた「単語」を読むコマンドと、数字を外部形式から内部形式に変換するコマンド、それにIF ... ELSE構成がある。

> 彼は、⾃由形式の⼊⼒が、特定の列にフォーマットするという、より⼀般的なFortranのやり⽅、これは列間違いにより果てなく再実⾏を繰り返す結果になるやり⽅よりも効率的で(より⼩さく、より速いコード)、信頼できるものであることを発⾒しました。

その背景には、既存のプログラムに対する不信と、

## FORTHの発展

スタンフォード時代に、スタンフォード線形加速器センターでプログラムを書き、2マイル電子加速器のビームステアリングを最適化したという。

> そのプログラムを制御するために、彼は自分のインタプリタを拡張し、パラメータ渡しのためのプッシュダウンスタック、明⽰的に値を取得・保存できる変数、算術・⽐較演算⼦、⼿続きを定義・解釈する機能などを管理できるようにしたものを使⽤した。

1965年からはフリーのプログラム書きとして様々な仕事をこなした。都度、インタプリタを活用していた。

> 60年代終盤にはミニコンピュータが登場し、それに伴ってテレタイプ端末が登場したが、ムーアはこの端末⽤に演算⼦を追加して⽂字の⼊出⼒を管理するようになった。

1968年、モハスコインダストリーズ社に入社し、そこで、IBM1130ミニコンピュータ+2250グラフィックディスプレイ用のコンピュータグラフィックスプログラムを開発した。

> 2250⽤のコードを⽣成するために、プログラムにクロスアセンブラを追加し、さらにプリミティブエディタとソース管理ツールも追加しました。このシステムは、IBMのソフトウェアが静的な2D画像しか描けなかった時代に、アニメーションの3D画像を描くことができた。また、遊びで、初期のビデオゲーム「Spacewar」を書いたり、「Algol Chess」プログラムを、初めて「FORTH」と呼ばれる新しい⾔語に変換したりもした。彼は、FORTHが⾮常にシンプルになったことに感動した。

このころ、彼が育ててきたインタプリタ(もはや、実行環境といってもいいだろう)は Forth という名前を持つことになった。

> ムーア⽒は、2250をプログラミングするためのForthベースの1130環境が、1130のソフトウェアが開発されたFortran環境よりも優れていることに気づき、1130コンパイラに拡張した。その結果、ループコマンド、ソースを1024バイトのブロックに分けて管理する概念とその管理ツールなど、現在Forthで認識されているコンパイラの機能のほとんどが追加された。

> 最も重要なのは、辞書が追加されたことだ。⼿続きは名前を持つようになり、インタプリタは名前のリンクリストを検索して⼀致するものを探しました。これはスタンフォード⼤学のコンパイラーから学んだことで、1980年代までForthで広く使われていた。

1130システム上で、辞書・コンパイラが確立してゆく。また、リターンスタックも入った。

> 最後に、ルーチンをネストするための簡単なメカニズムを提供するために、「リターンスタック」と呼ばれる第2のスタックが追加された。リターンアドレス用に予約されたスタックを持つことの利点は、呼び出しの前後に「バランス」を取る必要がなく、もう1つのスタックをパラメータ受け渡しに自由に使えることであった。

モハスコ社でのプロジェクトと中断、この時代に「タスクを定義し管理する仕組み」「現在使われている仕組みに似たディスクブロックバッファ」が導入されている。

> Forthに関する最初の論文はモハスコ社で書かれた [Moore,1970a]。1970年、モハスコ社は、新しい Univac 1108で受注システムのための専用線ネットワークを処理するという野心的なプロジェクトをMoore氏に任せた。彼は、Forthを 1108に移植し、トランザクション処理を行う COBOLモジュールとのインタフェースを確保した。1108の Forthは、アセンブラでコード化されていた。入出力のメッセージをバッファリングし、各行を処理するタスク間でCPUを共有する。また、入力を解釈し、適切な COBOLモジュールを実行した。このバージョンの Forthには、タスクを定義し管理する仕組みや、現在使われている仕組みに似たディスクブロックバッファを効率的に管理する仕組みが追加されていた。

このころ、[PROGRAMMING A PROBLEM ORIENTED LANGUAGE, Moore, 70b]を書いた。

> しかし、不況のあおりを受けて、モハスコ社は1108プロジェクトの完成を待たずに中止を決定した。Mooreは直ちにその旨を伝え、怒りの詩を書き、出版されることのなかったForthに関する本 [Moore, 1970b]を書きました。それは、Forthソフトウェアの開発方法を説明し、シンプルさと革新性を奨励するものでした。

私がこの本を書こうと思ったきっかけである。1970年、万国博覧会が万博と呼ばれていたころ、アメリカ東海岸でのできごとである。C言語もない(C言語誕生は1972年である)、コンピュータ付属のコンパイラ・ライブラリが玉石混交だった(ドラゴンブック第1版の発売が1986年であった。その前10年程度は研究テーマとなるくらいで、市井のプログラム書きがコンパイラ理論など知っているはずがない、そんな時代につくられたツールの品質たるやどんなものなのだったろうか)ころ、「人が作ったソフトウェアは信用できない、自分の手で自分のアプリケーションに必要な機能を構築するのだ」という意思に基づいて生まれたソフトウェア構築環境、それがForthだった。







