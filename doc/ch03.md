# 3. Forth処理系

この章では、Forth処理系を簡単に説明する。Forthは「言語」なのだが、文法や意味(Syntax and Semantics)という枠組みで説明したくない。というか、文法と意味という枠組みに対応するプロセッサは存在しない。入力としてFORTH「言語」で書かれたプログラムがどのようにして解釈実行されるのか、という実行系を説明のメインに置く。

Forth処理系は、トークナイザ、パーザという枠組みでソースコードを解釈しない。ソースコードを受け取ったForth処理系は、ソースコードからワードを一つきりだし、それを実行するだけである。「IF ... ELSE ... THEN」「DO ... WHILE」などの制御構造は利用できるが、それは、IFというワード、ELSEというワード、THENというワードがそれぞれの処理を行うだけのことで、IF ... ELSE ... THENという構造自体を切り出して処理するわけではない。

「文法を満たさないプログラム」をForth処理系は撥ねない。文法エラーだから処理しませんにならないのだ。THEN で終端されていないIF文であってもそのまま実行して訳の分からないことになるだけである。プログラムをざっくり書いて文法チェックをコンパイラに任せている私には到底ついてゆけない厳しさなのだ。こんな言語処理系の「文法」を理解して意味があるのだろうか。

この本のテーマは、Moore師匠の旅路をたどることにある。具体的には「19番目の新規のCPUの上で処理系を動かさねばならなくなったMoore師匠に代わって私が処理系を『実装』する」ので、実装対象のプログラムである処理系のイメージを読者の皆様にも伝えておきたい。ここでそれを行う。

## Forth処理系の哲学

Moore74の最初、「Philosophy」の章に処理系の背景と概要が書いてある。

時は70年代初頭、ミニコンピュータが台頭してきていたが、その開発環境は貧弱なものだった。高級言語を効率的に実行することができず、アセンブリ言語でプログラミングすることになる。手練れのプログラマと多大な労力が必要であり、コスト、開発期間、品質に不満を持たれていた。Forthはこの課題に対する一つの方向を示している、そうMoore師匠は言うのだ。

> FORTHは、コンピュータとの効果的なコミュニケーションという問題に対する新しいアプローチです。FORTHは、動詞、名詞、定義語を要素とする英語風の言語である。動詞はコンピュータの一連の操作を引き起こし、名詞は操作される対象であり、定義語は以前に定義された言葉の観点から、あるいは機械命令の観点から、新しい言葉を定義させる。

言語としては、動詞、名詞、定義語を持つと言っている。定義語はForthならではの特徴あるワードであり、変数定義、定数定義の単語は標準的に提供される。「定義語を構成する機能を持つワード」が提供されるので、ユーザが自分で自分用の定義語を作ることができる。

> FORTHは、プログラマが自分の特定の問題を記述するために拡張できる基本的な語彙を提供する。基本語とは、語彙を構成し、並べ替え、テストするために必要な語であり、簡単で便利なものである。このようにFORTHは、通常ならば、アセンブリ言語、コンパイラ言語、ジョブコントローラ言語、アプリケーション言語を必要とする範囲をこれ一つでカバーする言語を提供します。

アセンブリ言語、コンパイラ言語、ジョブコントローラ言語、アプリケーション言語をまとめてカバーする単一の言語。ワードを対話的に実行・定義できるので、今の言葉で言えば統合開発環境なのである。Lisp処理系や、Unixシェルと同列に置かれる機能を持っていると私は思う。

> FORTHは多くのレベルで有用です。プログラマにとっては、コアに常駐するアセンブラとコンパイラを提供し、ソースから再コンパイルすることでオブジェクトプログラムをロードする必要がありません。このような機能は、通常、非常に大きなメモリを持つ大型コンピュータにしかないものです。また、プログラマには、プログラムの作成と修正を容易にするテキストエディタが用意されています。また、独立した(複数のプログラムを持つ)タスクを簡単に記述する方法を提供します。

常駐するアセンブラ、コンパイラにより、ワードの定義・実行という開発サイクルを短時間で回すことができる。開発サイクルのスピードを見れば、現代の我々がソースコード修正-コンパイル-実行で享受するサイクルのスピードに近いサイクルで回せるということなのだろう。短時間で回すことができることは、今も昔も重要なことなのだろうと思う。

テキストエディタも提供されている。テキストバッファ上の固定長の行の並びから、行番号を指定して追加、削除、入替を行うワードが提供されており、Unixの ed のようなラインエディタである。テキストバッファは64文字×16行を一単位とする。この単位でハードディスクに読み書きする機能も提供される。

> ユーザにとっては、要求の厳しいリアルタイムアプリケーションも扱える効率的な語彙と、込み入った状況を診断する際に特に有用な広範な語彙を提供してくれます。さらに、必要に応じてデータブロックをディスクからコアへ、またディスクへ自動的に移動させるディスクルーチンにより、コアが提供するよりもはるかに多くのメモリに簡単にアクセスできるようになります。

ディスクアクセスは、1024バイト単位のブロック番号を指定してディスクバッファに読み書きするワードが提供されている。ユーザは読み込んだデータの参照(ブロック内へのメモリアクセスを使用する)、書き換え(メモリ書き換えに加え、そのバッファが dirty になったことを保持する)、書き出しが行える。ユーザが明示的に書き出すほかに、新たなブロックを読み込むバッファがなくなると、既に埋まっているバッファを開放し(dirtyビットが立っている場合は裏でディスクへの書き込みを行う)、空のバッファを確保する。

今回の旅路では、「アセンブラ」「テキストエディタ」「ディスクアクセス」機能は扱わない。ホストマシンの組み合わせ、ホストマシン側でのアセンブリ言語コード開発を行うためである。はっきり言って「ずる」だが、さすがにラインエディタとファイルシステムのないブロック番号管理のディスク上でのソースコード管理はご容赦頂きたい。

## Forth処理系の概要

Forth処理系を一言でいえば、インタプリタである。ターミナル/ファイルから入力されるテキスト列を解釈し、実行する。

解釈と実行は単純なループである。

* 次の空白で区切られた文字列を切り出し、
* それが数値であれば、データスタックトップにその数値を置き、
* それが数値でなければ、その文字列に対応する実行コードを探し出して呼び出す。
* 終われば次の文字列の切り出しを始める  
  (次の文字列が無ければ実行を停止する)

これだけである。Forthには制御構造、変数、定数、算術演算が当然存在するが、それらは、制御構造を構成するワードの実行により実現される。IFが出てくると、IF文の最後までソースコードを舐めて切り出すのではなく、IFの場所で行うべき処理(スタックトップの「判定式」の値により条件ジャンプ)を行うだけである。変数を定義する単語(`VARIABLE`)の実行では、「次の文字列を切り出し辞書エントリを作り、その実行

* **空白で区切られた文字列** : Forthで文法らしいところがあるとすれば、この「空白で区切られた文字列」である。空白かそれ以外かだけなので、記号も数字もわけへだてなく文字列として扱われる。

* **数値であれば** : 先頭が数字から始まる文字列は数値とみなされ、数値に変換される。通常は整数に変換される。正の数負の数も問題ない。普通のForthでは浮動小数点数は使用できない。

* **データスタックトップ** : Forthでは演算対象の数値(オペランド)、サブルーチンの引数は全てForth処理系が管理するスタックの上にプッシュされる。このスタックをデータスタックという。例えば加算サブルーチンは、スタックトップの数値とその次の数値の和を計算し、スタック上の数値2つを消し、和の数値をスタックトップに置くのである。Forthがスタックマシンといわれるゆえんである。

* **文字列に対応する実行コードを探し出して** : この実行コードが「サブルーチン」になる。数値以外の文字列は**ワード**とみなされ、ワードと対応する実行コードのペアを保持するデータベース上で検索される。このデータベースが**辞書(Dictionary)**である。辞書中にそのワードのエントリが存在すれば、その中にあるサブルーチンを呼び出す。<br>
サブルーチンには2種類ある。一つは、機械語列で構成されるもの、もう一つは、辞書のエントリのアドレスの列を実行するものである。後者がForth処理系のカナメの一つとなる。

単純な例だと、コード
```
  1 2 + .
```
である。これは、
* 整数1をスタックトップに置き
* 整数2をその上に置き、
* それら2つの和を取りスタックトップに置いて  
  (`+`に対応するサブルーチンを辞書から探し出して実行する)
* スタックトップの値(3)を印字する  
  (`.`に対応するサブルーチンを辞書から探し出して実行する)

という一連の処理を実行する。

ワード`+`は「和を計算する」サブルーチンであり、ワード`.`は、「スタックトップの値を印字する」サブルーチンである。

辞書の中に、ワード`+`のエントリとワード`.`のエントリがあり、それぞれ上記のサブルーチンの機械語列を格納している。

## ワードを定義する

Forth言語でワードを定義することができる。定義したワードは辞書に追加され、以後にワードとして実行することができる。

ワードを定義するときは、実行したいワード列を`:`(コロン)と`;`(セミコロン)で囲む。例えば、
```
  : +1 1 + ;
```
である。何のことやらという感じであるが、これは「スタックトップの値を1増やす」ワード`+1`を定義しているのである。

定義されたワード、ここではワード`+1`のエントリの中には、実行コードとして、
* 数値1をスタックトップに置くワードエントリのアドレス
* ワードエントリ`+`のアドレス

の2アドレスを持つ。このように、ワードを定義すると**ワードのアドレスの列**を含むエントリが生成され、辞書に追加される。ワード `+1`が実行されると、その中のアドレス列を手繰りながらワードを順次実行してゆく。

## スタックを介したオペランド渡し

ワードがサブルーチンにより実行される、その引数はスタック上に置かれる。数値演算の単項演算子はスタックトップの値1つをオペランド(処理対象)とする、二項演算子はスタックトップとその下の値の2つをオペランドとする。

通常の数式
```
  2 + (3 * 4)
```
は、スタック操作を用いて記述すると、
```
  2 3 4 * +
```
となり、演算子の結合関係を記述するための括弧が不要になる。これにかぎらず、任意の数式を括弧なしで記述することができ、スタック操作に基づく処理で任意の数式を表現できる。

> Fortran はじめ他の言語が数式を数式のまま記述して与え、言語処理系に解釈させることと異なり、Forthは数式のまま与えることは選ばず、プログラマに数式を逆ポーランド記法に変換させ、実行エンジンをスタックオペレーションだけの単純化させることを選んでいる。処理系を単純にすることを志向しているのではないか、そんな気がする。

## 内部インタプリタ: ワードアドレス列の実行

先ほど、ワードの定義により、ワードアドレスの列を含むエントリができることを説明した。あるワードを打ち込むと、そのワードが実行される。この処理は先に説明したとおりだが、その中で、文字列に対するコードを探し出して実行する、という記述があった、文字列をワードとして辞書を検索して見つけたエントリの中にアドレス列が格納されている場合、それはどのようにして実行されるのか?

アドレス列の実行のために、インストラクションポインタ(IP)というアドレスレジスタを用意し、そこにアドレス列の先頭のアドレスを格納する。すると

1. IPが指す先のメモリに格納された値を取り出し、
2. それがワードの実行ルーチンを指すとしてサブルーチンコールする。
3. サブルーチンの処理が終わるとIPをインクリメントする。

の処理をアドレス列の末尾に至るまで繰り返すだけである。このままでは末尾で零れ落ちてしまうので、アドレス列の最後のアドレスが指す先は、「アドレス列の実行を完了し、そのワードを呼び出したもと(それも別のワードのアドレス列の途中である)に戻り、次のアドレスを実行する」となる。

ワードの呼び出し元に戻るために、IPの戻り番地を保持するスタックを用意する。これをリターンスタックという。

## 仮想Forth実行マシン

Forth処理系は、

* ソースコードを読み込み単語に区切り辞書を引き、見つけたワードを実行する。
* ワードの実行において、ワード中のコード(機械語コードまたはワードアドレスの列)を実行する。

の2つの処理を行う。前者を外側インタプリタ(outer interpreter)、後者を内側インタプリタ(inner interpreter)と呼ぶ。内側インタプリタは、「データスタック、リターンスタック、インストラクションポインタ」を用いて処理する。

内側インタプリタを実行する仮想的なCPUを考えることができる。
* データスタックポインタ
* リターンスタックポインタ
* インストラクションポインタ