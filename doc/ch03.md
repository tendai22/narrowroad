## Forth処理系

この章では、Forth処理系を簡単に説明する。Forthは「言語」なのだが、文法や意味(Syntax and Semantics)という枠組みで説明したくない。というか、文法と意味という枠組みに対応するプロセッサは存在しない。入力としてFORTH「言語」で書かれたプログラムがどのようにして解釈実行されるのか、という実行系を説明のメインに置く。

Forth処理系は、トークナイザ、パーザという枠組みでソースコードを解釈しない。ソースコードを受け取ったForth処理系は、ソースコードからワードを一つきりだし、それを実行するだけである。「IF ... ELSE ... THEN」「DO ... WHILE」などの制御構造は利用できるが、それは、IFというワード、ELSEというワード、THENというワードがそれぞれの処理を行うだけのことで、IF ... ELSE ... THENという構造自体を切り出して処理するわけではない。

「文法を満たさないプログラム」をForth処理系は撥ねない。文法エラーだから処理しませんにならないのだ。THEN で終端されていないIF文であってもそのまま実行して訳の分からないことになるだけである。プログラムをざっくり書いて文法チェックをコンパイラに任せている私には到底ついてゆけない厳しさなのだ。こんな言語処理系の「文法」を理解して意味があるのだろうか。

この本のテーマは、Moore師匠の旅路をたどることにある。具体的には「19番目の新規のCPUの上で処理系を動かさねばならなくなったMoore師匠に代わって私が処理系を『実装』する」ので、実装対象のプログラムである処理系のイメージを読者の皆様にも伝えておきたい。ここでそれを行う。

### Forth処理系の哲学

Moore74の最初、「Philosophy」の章に処理系の背景と概要が書いてある。

時は70年代初頭、ミニコンピュータが台頭してきていたが、その開発環境は貧弱なものだった。高級言語を効率的に実行することができず、アセンブリ言語でプログラミングすることになる。手練れのプログラマと多大な労力が必要であり、コスト、開発期間、品質に不満を持たれていた。Forthはこの課題に対する一つの方向を示している、そうMoore師匠は言うのだ。

> FORTHは、コンピュータとの効果的なコミュニケーションという問題に対する新しいアプローチです。FORTHは、動詞、名詞、定義語を要素とする英語風の言語である。動詞はコンピュータの一連の操作を引き起こし、名詞は操作される対象であり、定義語は以前に定義された言葉の観点から、あるいは機械命令の観点から、新しい言葉を定義させる。

言語としては、動詞、名詞、定義語を持つと言っている。定義語はForthならではの特徴あるワードであり、変数定義、定数定義の単語は標準的に提供される。「定義語を構成する機能を持つワード」が提供されるので、ユーザが自分で自分用の定義語を作ることができる。

> FORTHは、プログラマが自分の特定の問題を記述するために拡張できる基本的な語彙を提供する。基本語とは、語彙を構成し、並べ替え、テストするために必要な語であり、簡単で便利なものである。このようにFORTHは、通常ならば、アセンブリ言語、コンパイラ言語、ジョブコントローラ言語、アプリケーション言語を必要とする範囲をこれ一つでカバーする言語を提供します。

アセンブリ言語、コンパイラ言語、ジョブコントローラ言語、アプリケーション言語をまとめてカバーする単一の言語。ワードを対話的に実行・定義できるので、今の言葉で言えば統合開発環境なのである。Lisp処理系や、Unixシェルと同列に置かれる機能を持っていると私は思う。

> FORTHは多くのレベルで有用です。プログラマにとっては、コアに常駐するアセンブラとコンパイラを提供し、ソースから再コンパイルすることでオブジェクトプログラムをロードする必要がありません。このような機能は、通常、非常に大きなメモリを持つ大型コンピュータにしかないものです。また、プログラマには、プログラムの作成と修正を容易にするテキストエディタが用意されています。また、独立した(複数のプログラムを持つ)タスクを簡単に記述する方法を提供します。

常駐するアセンブラ、コンパイラにより、ワードの定義・実行という開発サイクルを短時間で回すことができる。開発サイクルのスピードを見れば、現代の我々がソースコード修正-コンパイル-実行で享受するサイクルのスピードに近いサイクルで回せるということなのだろう。短時間で回すことができることは、今も昔も重要なことなのだろうと思う。

テキストエディタも提供されている。テキストバッファ上の固定長の行の並びから、行番号を指定して追加、削除、入替を行うワードが提供されており、Unixの ed のようなラインエディタである。テキストバッファは64文字×16行を一単位とする。この単位でハードディスクに読み書きする機能も提供される。

> ユーザにとっては、要求の厳しいリアルタイムアプリケーションも扱える効率的な語彙と、込み入った状況を診断する際に特に有用な広範な語彙を提供してくれます。さらに、必要に応じてデータブロックをディスクからコアへ、またディスクへ自動的に移動させるディスクルーチンにより、コアが提供するよりもはるかに多くのメモリに簡単にアクセスできるようになります。

ディスクアクセスは、1024バイト単位のブロック番号を指定してディスクバッファに読み書きするワードが提供されている。ユーザは読み込んだデータの参照(ブロック内へのメモリアクセスを使用する)、書き換え(メモリ書き換えに加え、そのバッファが dirty になったことを保持する)、書き出しが行える。ユーザが明示的に書き出すほかに、新たなブロックを読み込むバッファがなくなると、既に埋まっているバッファを開放し(dirtyビットが立っている場合は裏でディスクへの書き込みを行う)、空のバッファを確保する。

今回の旅路では、「アセンブラ」「テキストエディタ」「ディスクアクセス」機能は扱わない。ホストマシンの組み合わせ、ホストマシン側でのアセンブリ言語コード開発を行うためである。はっきり言って「ずる」だが、さすがにラインエディタとファイルシステムのないブロック番号管理のディスク上でのソースコード管理はご容赦頂きたい。

### Forth処理系の概要

Moore74bによると、Forthには重要な要素が5つあるという。それらは、
* 辞書(Dictionary)
* スタック
* インタプリタ
* アセンブラ
* 二次記憶(Secondary Memory)

だそうな。ここでは、Moore74bに従ってこの5つを説明してゆく。

Forthは基本的にボキャブラリ(ワードの集合)であり、そのボキャブラリの中で何が「ワード」を構成しているのかを理解することが重要です。

ワードとは、空白で区切られた任意の文字列のことです。ワードを構成できない特別な文字や、ワードを開始できない文字はありません。したがって、算術演算子を表す文字や、句読点に似た文字も、空白で区切られていればワードとなり得る。例えば、次のようなものがワードです。
```
 FORTH re-start + IF, ? */. 2@ 3.14 1-0
```

#### 辞書(Dictionary)

Forth言語は辞書によって構成されています。これは、プログラムが使用するメモリのほとんどすべてを占めます。その機能は、ボキャブラリの中の各ワードの定義を提供することである。これには、動詞が行うべき操作も含まれる。また、この辞書には、最も頻繁に参照される名詞も含まれている。

Forth処理系は辞書の中のワードを見つける機能、ワードを追加する機能、コンテキストにより辞書の一部分を選択する機能を持っている。

ワードは「定義語」によって辞書に追加されるが、その中でも特によく使われるのは3つである。1つは`;(セミコロン)`であり、端末からのメッセージの中で遭遇したとき、その直後のワードを辞書に登録する。それ以前に定義された単語を用いたこのワードの定義もまた、辞書に登録される。たとえば
```
: APPLE MEDIUM SIZE ROUND RED FRUIT;
```
は、APPLEの定義です。

もう一つの定義語は`CODE`である。これは、その次のワードが機械語命令によって定義されることを示すもので、この機械語命令も辞書に登録されます。例については後述します。

3つ目の定義語は`INTEGER`で、これも同様に次のワードを辞書に登録する。しかし、この場合、ワードは名詞であり、その値のために辞書の位置が確保される。たとえば 

```
100 INTEGER DATA
```
は名詞 DATA を定義し、その値を 100 に設定します。

#### スタック

プッシュダウン式のスタックは、ユーザとユーザが使うワード、およびあるワードと別のワードの間のデータのやり取り(communication)を提供します。例えば，ユーザは数字(あるいは他のオブジェクト)をスタックに置き，次にあるワードを打ち込むことで、スタック上で作用して望みの結果を得ます。例えば、次のように
```
12 2400 * 45 / .
```
と入力すると、`12` と `2400` という数字をスタックに置き、それらを掛け合わせ (ワード`*`)、`45` をスタックの一番上に置き、前の結果を`45`で割って(`/`)、その結果をタイプ(`.`)します。

このスタック(データスタック)とは別にリターンスタックというものもある。

#### インタプリタ

FORTHには2つのインタプリタがある。高レベルのインタプリタと低レベルのインタプリタである。

高レベルのインタプリタは、端末から単語を読み、辞書を検索し、見つけたエントリを実行する。

低レベルのインタプリタは、他のワードにより定義されたワードを実行する。先ほどのAPPLEの定義がその例になる。低レベルのインタプリタはAPPLEを見ると、MEDIUM、SIZE、ROUND、RED、FRUIT、';'の順に実行することになる。

これらの単語はすでにコンパイルされているので、この作業は極めて単純である。つまり、APPLEという単語を定義するときに、その定義に含まれる各単語を辞書で検索し、その結果の辞書アドレスをAPPLEのエントリに配置してある。APPLEが実行されたとき、インタプリタはこれらのアドレスをたどって必要なコードを実行すればよい。APPLEを定義するテキストは保存されない。

低レベルインタプリタには、いくつかの重要な特性がある。まず、高速であること。実際、いくつかのコンピュータでは、ワードそのものが意味するコードに加えて、追加で実行される命令数はワード一つにつきわずか2命令でしかない。第二に、定義がコンパクトになる。定義で使われる各ワードがコアで占める場所は1箇所だけである。あるワードを他のワードで定義する場合、その定義を解釈するコンピュータに依存しないためである。

その結果、FORTHのボキャブラリのほとんどは低レベルのインタープリタによって定義され、解釈されることになる。高レベルのインタプリタ自体も、別のワードを用いた定義である。

#### アセンブラ

アセンブラについては、Moore74bの記述をそのまま示しておく。

> CODEという定義語を使って、プログラマは指定された機械語命令を実行させる語を定義することができる。このような定義は、I/Oの実行、算術演算の実装、その他機械に依存する処理を行うのに必要である。
>
> これは、FORTHの重要な特徴である。FORTHは、コンピュータに依存したコードを、管理しやすい大きさに分割し、特定のインターフェイスの規則で明示することを可能にします。アプリケーションを別のコンピュータに移植するには、CODE語だけを再コード化すればよく、他の語とはコンピュータに依存しない形で相互作用します。
>
> アセンブラが解釈する言葉の中には、命令ニーモニックがあります。各ニモニックは、対応する機械語命令をアセンブルするように定義されている。例えば、次のようなフレーズ
> ```
> X LDA,
> ```
> は、LDA命令をXの適切なアドレスでアセンブルし、辞書に置く。
> 
> このアセンブラは非常にコンパクトです。その主なコストは、ニーモニックが占める辞書のスペースで、通常250コアロケーションです。プッシュダウン・スタックは、従来のアセンブラで必要だったシンボルテーブルを大幅に削減する。これは、コアの位置に名前を付ける必要がないためです。動詞は、名前を付けた場所からパラメータを取り出すのではなく、スタック上でパラメータを見つけます。同様に、条件付きジャンプは、後で説明する方法で、アセンブル時にプッシュダウンスタックを使用します。ただし、変数とロケーションには名前を付けることができ、そのような名前は通常通り辞書で見つけることができます。

機械語で記述したサブルーチンを含むワードは必要不可欠なので、処理系全てをメモリ上に載せるためには、オンコアアセンブラが必要というのは理解できる。が、ニーモニック辞書が250ワードで収まり、オペランドの代わりにスタック中の位置を指す、条件付きジャンプの飛び先をリターンスタックを使って保持しておく。我々が普通に知っているアセンブリ言語とだいぶ異なるのではないかという気がする。

Moore74bでは5大項目の一つとして扱われるアセンブラであるが、その後のForthの展開の中では重要でなくなったせいか、あまり見かけることはなくなった。いくつかの歴史的文献をあさっているが、アセンブラの具体的実装をまだ見つけられていない。私自身もよくわかってないので、本書ではこれ以上触れることはしない。残念だが。

#### 2次記憶

同じく、Moore74bでの説明を記す。

> FORTHの最後の重要な要素は、ブロック-1024バイトの二次記憶装置です。2つのコアバッファが提供され、ブロックは必要に応じて読み込まれます。ブロックがコアで変更されると、そのバッファが再利用されるときに、ディスク上のイメージが自動的に置き換えられます。プログラマは、自分のデータがいつでもコアにあると考えることができるため、非常に小さなコストで、非常に大きなサービスを提供することができます。
> 
> ブロックは、語彙を定義するテキストを格納するために使用されます。このブロックは、ユーザが要求したときにコアにコンパイルされる。編集ボキャブラリは、ブロックを64文字で16行にフォーマットします。これにより、ユーザは自分のソースコードを修正したり、再コンパイルしたりすることができる。
> 
> また、ブロックはデータの保存にも使われる。小さなレコードを1つのブロックにまとめたり、大きなレコードを複数のブロックに分散して格納したりすることが容易にできる。ブロックはコンピュータに関係なく同じ形式なので、アプリケーションをあるコンピュータから別のコンピュータに移すのも簡単です。

* 1ブロック1024バイトであること。
* バッファ2つをキャッシュとして使う。ライトバック。
* テキストバッファとして使うときは64文字×16行、固定長行数。
* テキストバッファ上のテキストを編集するコマンド群を持つ。

Starting Forthには、ディスクアクセスと編集コマンドの説明がある。さすがにファイルシステムがない裸のディスクアクセスと、ラインエディタでプログラムを書く気にはなれないので、この2つについてはこれ以上追いかけない。

### Forth処理系を簡単に説明する

Forth処理系全体は、一言で言うと、ターミナル/ファイルから入力されるテキスト列を解釈し、実行するものといえる。解釈と実行は以下のような単純なループである。

* 次の空白で区切られた文字列を切り出し、
* それが数値であれば、データスタックトップにその数値を置き、
* それが数値でなければ、その文字列に対応する実行コードを探し出して呼び出す。
* 終われば次の文字列の切り出しを始める  
  (次の文字列が無ければ実行を停止する)

Forthには制御構造が当然存在するが、それらは、制御構造を構成するワードの実行により実現される。IFが出てくると、IF文の最後までソースコードを舐めて切り出すのではなく、IFの場所で行うべき処理(スタックトップの「判定式」の値により条件ジャンプ)を行うだけである。変数を定義する単語(`VARIABLE`)の実行では、「次の文字列を切り出し辞書エントリを作り、その実行

* **空白で区切られた文字列** : Forthで文法らしいところがあるとすれば、この「空白で区切られた文字列」である。空白かそれ以外かだけなので、記号も数字もわけへだてなく文字列として扱われる。

* **数値であれば** : 先頭が数字から始まる文字列は数値とみなされ、数値に変換される。通常は整数に変換される。正の数負の数も問題ない。普通のForthでは浮動小数点数は使用できない。

* **データスタックトップ** : Forthでは演算対象の数値(オペランド)、サブルーチンの引数は全てForth処理系が管理するスタックの上にプッシュされる。このスタックをデータスタックという。例えば加算サブルーチンは、スタックトップの数値とその次の数値の和を計算し、スタック上の数値2つを消し、和の数値をスタックトップに置くのである。Forthがスタックマシンといわれるゆえんである。

* **文字列に対応する実行コードを探し出して** : この実行コードが「サブルーチン」になる。数値以外の文字列は**ワード**とみなされ、ワードと対応する実行コードのペアを保持するデータベース上で検索される。このデータベースが**辞書(Dictionary)**である。辞書中にそのワードのエントリが存在すれば、その中にあるサブルーチンを呼び出す。<br>
サブルーチンには2種類ある。一つは、機械語列で構成されるもの、もう一つは、辞書のエントリのアドレスの列を実行するものである。後者がForth処理系のカナメの一つとなる。

単純な例だと、コード
```
  1 2 + .
```
である。これは、
* 整数1をスタックトップに置き
* 整数2をその上に置き、
* それら2つの和を取りスタックトップに置いて  
  (`+`に対応するサブルーチンを辞書から探し出して実行する)
* スタックトップの値(3)を印字する  
  (`.`に対応するサブルーチンを辞書から探し出して実行する)

という一連の処理を実行する。

ワード`+`は「和を計算する」サブルーチンであり、ワード`.`は、「スタックトップの値を印字する」サブルーチンである。

辞書の中に、ワード`+`のエントリとワード`.`のエントリがあり、それぞれ上記のサブルーチンの機械語列を格納している。

### ワードを定義する

Forth言語でワードを定義することができる。定義したワードは辞書に追加され、以後にワードとして実行することができる。

ワードを定義するときは、実行したいワード列を`:`(コロン)と`;`(セミコロン)で囲む。例えば、
```
  : +1 1 + ;
```
である。何のことやらという感じであるが、これは「スタックトップの値を1増やす」ワード`+1`を定義しているのである。

定義されたワード、ここではワード`+1`のエントリの中には、実行コードとして、
* 数値1をスタックトップに置くワードエントリのアドレス
* ワードエントリ`+`のアドレス

の2アドレスを持つ。このように、ワードを定義すると**ワードのアドレスの列**を含むエントリが生成され、辞書に追加される。ワード `+1`が実行されると、その中のアドレス列を手繰りながらワードを順次実行してゆく。

### スタックを介したオペランド渡し

ワードがサブルーチンにより実行される、その引数はスタック上に置かれる。数値演算の単項演算子はスタックトップの値1つをオペランド(処理対象)とする、二項演算子はスタックトップとその下の値の2つをオペランドとする。

通常の数式
```
  2 + (3 * 4)
```
は、スタック操作を用いて記述すると、
```
  2 3 4 * +
```
となり、演算子の結合関係を記述するための括弧が不要になる。これにかぎらず、任意の数式を括弧なしで記述することができ、スタック操作に基づく処理で任意の数式を表現できる。

> Fortran はじめ他の言語が数式を数式のまま記述して与え、言語処理系に解釈させることと異なり、Forthは数式のまま与えることは選ばず、プログラマに数式を逆ポーランド記法に変換させ、実行エンジンをスタックオペレーションだけの単純化させることを選んでいる。処理系を単純にすることを志向しているのではないか、そんな気がする。

### 内部インタプリタ: ワードアドレス列の実行

先ほど、ワードの定義により、ワードアドレスの列を含むエントリができることを説明した。あるワードを打ち込むと、そのワードが実行される。この処理は先に説明したとおりだが、その中で、文字列に対するコードを探し出して実行する、という記述があった、文字列をワードとして辞書を検索して見つけたエントリの中にアドレス列が格納されている場合、それはどのようにして実行されるのか?

アドレス列の実行のために、インストラクションポインタ(IP)というアドレスレジスタを用意し、そこにアドレス列の先頭のアドレスを格納する。すると

1. IPが指す先のメモリに格納された値を取り出し、
2. それがワードの実行ルーチンを指すとしてサブルーチンコールする。
3. サブルーチンの処理が終わるとIPをインクリメントする。

の処理をアドレス列の末尾に至るまで繰り返すだけである。このままでは末尾で零れ落ちてしまうので、アドレス列の最後のアドレスが指す先は、「アドレス列の実行を完了し、そのワードを呼び出したもと(それも別のワードのアドレス列の途中である)に戻り、次のアドレスを実行する」となる。

ワードの呼び出し元に戻るために、IPの戻り番地を保持するスタックを用意する。これをリターンスタックという。

### 仮想Forth実行マシン

Forth処理系は、

* ソースコードを読み込み単語に区切り辞書を引き、見つけたワードを実行する。
* ワードの実行において、ワード中のコード(機械語コードまたはワードアドレスの列)を実行する。

の2つの処理を行う。前者を外側インタプリタ(outer interpreter)、後者を内側インタプリタ(inner interpreter)と呼ぶ。内側インタプリタは、「データスタック、リターンスタック、インストラクションポインタ」を用いて処理する。

内側インタプリタを実行する仮想的なCPUを考えることができる。
* データスタックポインタ
* リターンスタックポインタ
* インストラクションポインタ

### 大体の旅程

* 端末からの入力、出力
* 行入力
* ワードの定義、辞書を作る
* 低レベルインタプリタ
* 高レベルインタプリタ
* 定義語`:`, `:`
* 定義語VARIABLE, CONSTANT
* IF ... ELSE ... THEN
* DO ... WHILE
* 算術演算(整数加減乗除)

Moore70で規定される機械語ワードをそろえたところで旅の一区切りとしようか。

