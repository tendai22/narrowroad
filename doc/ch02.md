# Forthの「基本原則」{id=H02-1}

Mooreにとって、Forthの誕生は、当時のソフトウェアツールに対する不満に対するためのものだった。

> アセンブラはコンパイラとスーパーバイザを記述するための言語、スーパーバイザはジョブ制御のための言語、コンパイラはアプリケーションプログラムのための言語、アプリケーションプログラムはその入力のための言語を定義しているのです。ユーザはこれらすべての言語を知らないかもしれませんし、知ることもできないかもしれません。しかし、これらの言語は、ユーザとコンピュータの間に立ち、ユーザができることとそのコストに制約を課しているのである。
> 
> この膨大な言語の階層を作るには、人と機械の膨大な時間が必要であり、保守するにも同様に大きな労力を必要とします。これらのプログラムを文書化するのにも、その文書を読むのにも膨大なコストがかかる。そして、これだけ努力しても、プログラムはバグだらけで、使いづらく、誰も満足しないのである。

アセンブリ言語、ジョブ制御言語、アプリケーションプログラムのための言語、これらの言語を覚えて使うことがユーザに金と時間を使わせている。そのうえ、出来上がったプログラムはバグだらけで使いずらく誰も満足していない。

「この膨大な言語の階層」をForthという一層だけの構造に置き換え、最小限のアプリケーションインタフェースとプログラマとのインタフェースを提供する。これがMooreの考えるForthであった。

これは、「膨大な言語の階層」を当たり前としてそのうえで暮らす私には新鮮な考えだった。というか、古い・古すぎる、現代とのギャップが大きすぎる。

一方で、Forthの言語処理系、特にインタプリタの実装は面白かった。40年前にプログラム書きを始めた当時の8bit「パソコン」「マイコン」を使っていたときの経験から、メモリ16kByteでも十分実用になる単純さ・効率の良さは納得感のあるものだった。いくつかのForth入門書を読んで感じる特徴「浮動小数点数を導入せず、整数×整数÷整数の演算子を導入する(これは1未満の大きさの桁数を処理系任せにせず自分で管理することを意味すると考えた)、コンパイラ自身も書き換えることができる、その機能を使って「アプリケーション固有の言語を作れ」というアピール。

Evolution of Forth や、PROGRAMMING PROBLEM-ORIENTED LANGUAGEというForthの歴史書を読んで、この奇妙な言語は当時のコンピュータ環境に直面したMooreが自分なりに取り組んだ結果・回答なのだと分かった。

その結果、Moore74bには、私から見て一見みょうちくりんな主張が連発している。ここでは、それを説明し、私なりの解釈を添える。

## Keep it Simple!{id=H02-2}

Moore師匠の「基本原則」が Keep it Simple!である。この「基本原則」は古今を通じてプログラム書きの中で受け継がれているもので、この原則自体にみょうちくりんなところはない。

> プログラムに追加する機能の数が増えれば増えるほど、プログラムの複雑さは指数関数的に増していく。プログラムの内部的な整合性はもちろんのこと、これらの機能間の互換性を維持する問題は、簡単に手に負えなくなる。基本原則を適用すれば、これを回避することができます。基本原則を無視したオペレーティングシステムをご存じかもしれませんね。

これは良いですよね。最後の一文を除くと納得感あります。

> 基本原則を適用するのは非常に難しいことです。内外のあらゆる圧力が、プログラムに機能を追加しようと謀っているのです。結局のところ、半ダースの命令しか必要ないのだから、なぜそうしないのか？唯一の対抗力は「基本原理」であり、これを無視すれば対抗力は存在しない。

> 使われるかもしれないコードをプログラムに入れてはいけない。拡張機能をぶら下げるようなフックを置いてはいけない。あなたがやりたいと思うことは無限であり、それぞれが実現する確率は0である。もし後で拡張機能が必要になったら、後でコーディングすればいいのです - そしておそらく、今やるよりも良い仕事ができるはずです。そして、もし他の誰かがその拡張機能を追加したら、その人はあなたが残したフックに気づくでしょうか？あなたのプログラムのこの点を文書化しますか？

「使われるかもしれないコードをプログラムに入れてはいけない」この一文は重い。将来の拡張性、汎用性を常に意識しながらコードを書いてきた私だが、それは止めろと言われている。ちょっと待て！と言いたい気分だ。

「もし後で拡張機能が必要になったら、後で(そのときに)コーディングすればいいのです」これは、「あらかじめ要件を定め機能を定め作る」というアプローチと全く適合しない。プログラムを開発する過程で必要性に気づいた機能はその時点で作ればよいのだから、という意味なのだろうから。

だが、時間と締め切りの制約がないプログラミングだと、むしろこのアプローチの方がすがすがしい。遠い昔、時間と締め切りの制約のないプログラミング、プログラミングの中にプログラミングを忘れる経験をしたことがあるなら、この言葉の意味も実感できるかもしれない。

この辺りを読んだ時点で、Forthというものは単純に言語処理系・単純なインタプリタとして見てしまってはいけない、もっと深いものがあるのではないかという気になっていた。

## Do It Yourself!{id=H02-3}

この「なんでも自分でやれ」は結構恐ろしいことを言っている。Moore78の最初に書かれている基本原則の系「Do It Yourself!」には「標準的なライブラリを使うべきという通例に従わずに、自分でサブルーチンを書きなさい」とある。産まれたときからlibcを当たり前のように使ってきた私としては「なんじゃこりゃー」である。

Moore師匠曰く、

> ⾃分でサブルーチンを書く前に、書き⽅を知らなければならない。これは、現実的には、以前に書いたことがあるということであり、そのため、始めるのが難しいのです。しかし、⼀度試してみてください。同じサブルーチンを何台ものコンピュータと⾔語で何⼗回も書いているうちに、かなり上⼿になるはずだ

ということなのだ。最初は難しいが、何度も書いていればそらで書けるようになるといっているのだろう。そういう経験ならば私にもある。さすがに、アセンブリ言語の世界でそれを実践したことはないが。

有言実行、Moore師匠は「これを驚くほど忠実に実行した」のだそうな。

> ムーアは、これを驚くほど忠実に実行した。1970年代を通じて、彼は18種類のCPUにForthを実装し(表1)、必ずそれぞれに独自のアセンブラ、独自のディスクおよびターミナルドライバ、さらには独自の乗除算サブルーチン(多くのマシンで必要とされていた)を書きました。これらの関数についてメーカー提供のルーチンがある場合、彼はそれを読んでアイデアを得ましたが、そのまま使うことはありませんでした。Forthがこれらのリソースをどのように使うかを正確に把握し、フックや一般性を省き、また、熟練と経験によって(彼は、ほとんどの乗除算サブルーチンは、これまで書いたことがなく、これからも書くことがない人が書いたと推測しています)、彼のバージョンは常に小さく、速く、通常は著しく速くなりました。

CPU 18種類を渡り歩き、それぞれに自作アセンブラ、自作のディスクドライバ、自作のターミナルドライバ、自作の乗除算サブルーチンを用意したというのだ。もちろんアセンブリ言語で記述した。

C言語が使える現在の我々は、全て自作でそろえるにしてもC言語で書いたモジュールを使いまわすでしょう。事実シリアルI/OやSDcard/FatFSルーチンはそうしている。誰かが十分効率的な(コード効率がいい、くそくなこーどを吐く)C言語処理系をそのCPUのために用意してくれることを疑うことはない。また、GCCのCPUサポート数の多さもそれを後押ししている。何年も、10何年もの蓄積の上になりたっている高品質のソフトウェアの上で私たちは生活することができている。

しかしながら1970年代、万国博覧会が万博と呼ばれていたころ、C言語もGCCもなかった。ドライバも乗除算ルーチンも全てアセンブリ言語で書くしかない。一方でCPU付属のアセンブラも乗除算ルーチンも結構怪しいものだったのだろう。乗除算ルーチンも結構ノウハウの塊であり、正しく計算できるレベルからがりがりにチューンして高速化を図った結果のコードとは性能差は歴然だっただろう。

数回自分でやっているうちに、ディスクドライバもターミナルドライバも乗除算ルーチンも何度か書いて勘所はわかっている。一方でメーカ提供のアレはあそことかこことか配慮がないなぁ、怪しいコードや。これなら自分でやった方が速くてまともなものができる。あたりがMoore師匠のお考えではなかったのか。

Forthという言語処理系ができた時代の環境・バックグラウンドは現在とだいぶん違うらしい。18種類のCPUの全てに対して、「全部自分でやった」結果、研ぎ澄まされた処理系がForthではないのか？そんな気がするのだ。

アセンブリ言語だけしか使えない環境下でディスクI/OもシリアルI/Oも天文アプリケーションも動くようにする。全部がForth言語処理系の中にある。なるほど、面白い。
